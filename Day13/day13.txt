day11回顾
    函数式编程
        建议使用可重入函数
            可重入函数不一定不使用除局部变量以外的变量
    高阶函数:
        map(func, 可迭代对象1,可迭代对象2......)
        filter(func, 可迭代对象)
        sorted(可迭代对象, 可以= None, reverse=False)
    递归函数:
        函数直接或间接调用自身
    闭包 closure
        内嵌函数引用外部变量,返回内嵌函数叫做闭包



day12

装饰器 decorator(专业提高篇)
    作用:
        通常在不改变原函数的情况下,改变或添加原函数功能
    什么是装饰器:
        装饰器是一个函数,能常用来包装另一个函数或类(后面才讲)

函数装饰器
    是指装饰器函数,传入的是函数,返回的也是函数

    语法:
        def 装饰器函数名(形参):
            语句块
            return 函数对象

        @装饰器函数名
        def 函数名(形参列表):
            语句块
    示例见:
        mydeco.py
        mydeco1.py

函数的文档字符串:
    函数内第一次未赋值给任何变量的字符串是函数的文档字符串
    语法:
        def 函数名(参数列表):
            "函数的文档字符串"
            函数语句块
    示例:
        def cba():
            """ 这是一块文档字符串
            以下省却300字..."""
            pass
        >>> help(cba)

函数的__doc__属性
    __doc__ 属性用于记录函数的文档字符串
    如:
        print(cba.__doc__)

函数定义语句(def语句)的完整语法:    
    [@装饰器名1]
    [@装饰器名2]
    ...
    def 函数名([位置形参], [*元祖形参], [命名关键字形参], [**字典形参]):
        '文档字符串'
        语句块

面试题:
    L= [1,2]
    def f(n, lst[]):        #lst[]在函数定义时已经创建,如果没有实参传入,会调用缺省参数的值,和f绑定的函数一同存在
        lst.append(n)
        print(lst)
    f(3,L)      #[1,2,3]
    f(4,L)      #[1,2,3,4]
    f(100)      #[100]
    f(200)      #[100,200]
        
    解决方法:
        def f(n , lst=None):
            if lst == None:
            lst = []
            lst.append(n)
            print(lst)

        f(100)      #[100]
        f(200)      #[200]


    